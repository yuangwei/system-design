浏览器是怎么运行的
---

### 运行流程
解析
- HTML解析
- CSS解析

渲染
- 计算CSS样式
- 构建Render Tree
- 布局：计算每个元素的坐标等等
- 开始绘制

### 性能相关
Reflow and Repaint

众所周知Reflow带来的性能开销远大于Repaint，这是因为每一次Reflow的都需要从HTML根结点重新递归向下构建Render Tree。

以下是可能带来Reflow的几个动作：
- 增加、删除、修改Dom节点；
- 修改Dom位置；
- 修改CSS样式；
- Resize窗口
- 修改网页字体

总结来看Reflow出现有以下几个原因：
- Initial，网页初始化时；
- Incremental，一些Javascript在操作DOM Tree时。
- Resize，其些元件的尺寸变了。
- StyleChange，如果CSS的属性发生变化了。
- Dirty，几个Incremental的reflow发生在同一个frame的子树上。

浏览器默认会自己进行一些Reflow的性能优化，例如批量Reflow，但也有一些操作会阻止浏览器这么干，例如：
- offsetTop, offsetLeft, offsetWidth, offsetHeight;
- scrollTop/Left/Width/Height;
- clientTop/Left/Width/Height;

因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。

减少Reflow的几个方法：
- 批量更新Dom节点更改（React / Vue等框架就是干这个事的）；
- 离线修改Dom节点，例如把Dom节点先置为Display：none，修改完毕后再替换回去（这种方式实用价值不高，会影响用户体验）；
- 不要把DOM结点的属性值放在一个循环里当成循环里的变量；
- 尽可能的修改层级比较低的DOM；
- 为动画的HTML元件使用fixed或absoult的position，使其跳出当前文档流。



参考资料：
- http://taligarsiel.com/Projects/howbrowserswork1.htm
- https://coolshell.cn/articles/9666.html